---
import { imageData, namiImageData } from '@components/templates/top/data/topsection';
import ResponsiveImage from '@components/ui/ResponsiveImage.astro';
---

<section class="top">
	<h1>
		<p>
			<span>純</span><span>度</span><span>の</span><span>高</span><span>い</span>
		</p><p>
			<span>な</span><span>め</span><span>ら</span><span>か</span><span>な</span><span
			>し</span
			><span>あ</span><span>わ</span><span>せ</span>
		</p>
		<p>
			<span>親</span><span>密</span><span>な</span><span>温</span><span>度</span><span
			>の</span
			>
		</p>
		<p>
			<span>バ</span><span>タ</span><span>ー</span><span>サ</span><span>ン</span><span
			>ド</span
			>
		</p>
	</h1>
	{
		imageData.map((image, index) => {
			return (
				<div class={`top__image_${index + 1}`}>
					<ResponsiveImage
						src={image.src}
						alt={image.alt}
						sizes={image.sizes}
						loading={'eager'}
						decoding={image.decoding}
					/>
				</div>
			);
		})
	}
	{
		namiImageData.map((image, index) => {
			return (
				<div class={`top__nami_${index + 1}`}>
					<ResponsiveImage
						src={image.src}
						alt={image.alt}
						loading={image.loading}
						decoding={image.decoding}
					/>
				</div>
			);
		})
	}
	<div class="top__content">
		<p class="animated-element"><span>Sea,</span> <span>Forest &amp; City.</span></p>
		<p class="animated-element">
			<span>As it melts</span>
			<span>into the painting.</span>
		</p>
		<p class="animated-element"><span>Butter Sand,</span></p>
		<p class="animated-element"><span>the destination</span> <span>of memory.</span></p>
	</div>
</section>

<style lang="scss">
	@import '@styles/main.scss';
	.top {
		position: relative;
		height: 413vw;
		&__content {
			position: absolute;
			left: 12vw;
			top: 380vw;
			font-size: 4.2666666667vw;
			width: auto;
			height: auto;
		}
		h1 {
			position: absolute;
			right: 7.4666666667vw;
			top: 150.9333333333vw;
			font-size: 3.7333333333vw;
			width: auto;
			height: auto;
			font-size: 3.7333333333vw;
			writing-mode: vertical-rl;
			line-height: 1.2;
			p {
				margin-left: 4.2vw;
				&:nth-child(3),
				&:nth-child(4) {
					display: inline-block;
					margin-left: 0;
				}
			}
		}
		&__image_1,
		&__image_2,
		&__image_3,
		&__image_4,
		&__image_5,
		&__image_6,
		&__image_7,
		&__image_8,
		&__nami_1,
		&__nami_2,
		&__nami_3,
		&__nami_4 {
			position: absolute;
			z-index: 1;
			opacity: 0;
		}
		&__nami_1,
		&__nami_2,
		&__nami_3,
		&__nami_4 {
			opacity: 1;
		}
		&__image_1 {
			width: 64%;
			top: 47vw;
			left: calc(50% - 24.5vw);
		}
		&__image_2 {
			display: none;
		}
		&__image_3 {
			top: 131vw;
			left: -10.7vw;
			width: 42.7%;
		}
		&__image_4 {
			top: 180vw;
			left: 22.7vw;
			width: 32%;
		}
		&__image_5 {
			top: 0;
			left: calc(100% - 6.1vw);
			width: 36%;
		}
		&__image_6 {
			top: 243.7vw;
			left: 44vw;
			width: 64%;
		}
		&__image_7 {
			top: 328.8vw;
			left: 23.5vw;
			width: 32%;
			z-index: -1;
		}
		&__image_8 {
			top: 252.3vw;
			left: -12.5vw;
			width: 27%;
		}

		&__nami_1 {
			width: 103.4666666667vw;
			top: 74.6666666667vw;
			left: -56.2666666667vw;
		}
		&__nami_2 {
			width: 114.1333333333vw;
			top: 390vw;
			left: 9.3333333333vw;
		}
		&__nami_3 {
			width: 101.6vw;
			top: 117.8666666667vw;
			left: 42.4vw;
		}
		&__nami_4 {
			display: none;
		}
		.fade-in {
			@include fadeIn;
		}
		.animated-element {
			opacity: 0;
			transform: rotate(4deg) translate(-20px, -20px);
			transition:
				opacity 1s,
				transform 1s;
			&.is-visible {
				opacity: 1;
				transform: rotate(0deg) translateY(0);
			}
		}
		@include mq('md') {
			height: 100vw;
			h1 {
				font-size: 1.25vw;
				right: 18.75vw;
				top: 23.4375vw;
				p {
					margin-left: 2vw;
					&:nth-child(3),
					&:nth-child(4) {
						display: block;
						margin-left: 2vw;
					}
				}
			}
			&__content {
				font-size: 1.5625vw;
				left: 17.734375vw;
				top: 72.265625vw;
			}
			&__image_1 {
				top: 8.75vw;
				left: calc(50% - 18vw);
				width: 31%;
			}
			&__image_2 {
				display: block;
				top: -3.75vw;
				left: calc(50% + 10.15625vw);
				z-index: 0;
				width: 12.5%;
			}
			&__image_3 {
				top: 27.5vw;
				left: -3.515625vw;
				width: 18.8%;
			}
			&__image_4 {
				top: 47.265625vw;
				left: 11.71875vw;
				width: 12.5%;
			}
			&__image_5 {
				top: 16.09375vw;
				left: calc(100% - 12vw);
				width: 18.8%;
			}
			&__image_6 {
				top: 57.96875vw;
				left: 56.328125vw;
				width: 25%;
				z-index: 11;
			}
			&__image_7 {
				top: 90vw;
				left: 75vw;
				width: 18.75%;
				z-index: 10;
			}
			&__image_8 {
				top: 87.03125vw;
				left: 14.0625vw;
				width: 12.5%;
			}

			&__nami_1 {
				top: 29.21875vw;
				left: -1.328125vw;
				width: 30%;
			}
			&__nami_2 {
				width: 33.4375vw;
				top: 75.546875vw;
				left: 16.875vw;
			}
			&__nami_3 {
				width: 29.765625vw;
				top: 36.09375vw;
				left: calc(100% - 26vw);
			}
			&__nami_4 {
				display: block;
				width: 28.5%;
				top: 99.765625vw;
				left: 3.671875vw;
			}
		}
	}
</style>

<script>
	document.addEventListener('DOMContentLoaded', () => {
		const imageElements = Array.from(document.querySelectorAll('[class^=top__image_]'));
		function shuffleArray(array: Element[]) {
			for (let i = array.length - 1; i > 0; i--) {
				const j = Math.floor(Math.random() * (i + 1));
				[array[i], array[j]] = [array[j], array[i]];
			}
		}

		shuffleArray(imageElements); // 画像の要素の配列をシャッフル
		imageElements.forEach((element, index) => {
			setTimeout(() => {
				const htmlElement = element;
				htmlElement.classList.add('fade-in');
			}, index * 100); // 0.1秒ずつ遅延
		});

		const animatedElements = document.querySelectorAll('.animated-element');

		// Intersection Observerのコールバック
		const handleIntersect = (entries: IntersectionObserverEntry[]) => {
			console.log(entries);
			entries.forEach(entry => {
				if (entry.isIntersecting) {
					// 要素がビューポートに表示された場合
					entry.target.classList.add('is-visible'); // アニメーションクラスを追加
				}
			});
		};

		// Intersection Observerの設定
		const options = {
			root: null, // ビューポートを基準とする
			rootMargin: '0px',
			threshold: 0.1 // 少しでも表示されたらトリガー
		};

		const observer = new IntersectionObserver(handleIntersect, options);

		animatedElements.forEach(element => {
			observer.observe(element);
		});
	});
</script>
